# JUnit 5 User Guide

## Annotations

- Unless otherwise stated, all core annotations are located in the `org.junit.jupiter.api` package in the `junit-jupiter-api` module
- **`@Test`**: Denotes that a method is a test method
- **`@ParameterizedTest`**: Denotes that a method is a parameterized test
- **`@RepeatedTest`**: Denotes that a method is a test template for a repeated test
- **`@TestFactory`**: Denotes that a method is a test factory for dynamic tests
- **`@TestTemplate`**: Denotes that a method is a template for test cases designed to be invoked multiple times depending on the number of invocation contexts returned by the registered providers
- **`@TestMethodOrder`**: Used to configure the test method execution order for the annotated test class; similar to JUnit 4's `@FixMethodOrder`
- **`@TestInstance`**: Used to configure the test instance lifecycle for the annotated test class
- **`@DisplayName`**: Declares a custom display name for the test class or test method
- **`@DisplayNameGeneration`**: Declares a custom display name generator for the test class
- **`@BeforeEach`**: Denotes that the annotated method should be executed before each `@Test`, `@RepeatedTest`, `@ParameterizedTest`, or `@TestFactory` method in the current class; analogous to JUnit 4's `@Before`
- **`@AfterEach`**: Denotes that the annotated method should be executed after each `@Test`, `@RepeatedTest`, `@ParameterizedTest`, or `@TestFactory` method in the current class; analogous to JUnit 4's `@After`
- **`@BeforeAll`**: Denotes that the annotated method should be executed before all `@Test`, `@RepeatedTest`, `@ParameterizedTest`, and `@TestFactory` methods in the current class; analogous to JUnit 4's `@BeforeClass`; must be static (unless the "per-class" test instance lifecycle is used
- **`@AfterAll`**: Denotes that the annotated method should be executed after all `@Test`, `@RepeatedTest`, `@ParameterizedTest`, and `@TestFactory` methods in the current class; analogous to JUnit 4's @`AfterClass`; must be static (unless the "per-class" test instance lifecycle is used
- **`@Nested`**: Denotes that the annotated class is a non-static nested test class; `@BeforeAll` and `@AfterAll` methods cannot be used directly in a `@Nested` test class unless the "per-class" test instance lifecycle is used
- **`@Tag`**: Used to declare tags for filtering tests, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4
- **`@Disabled`**: Used to disable a test class or test method; analogous to JUnit 4's `@Ignore`
- **`@Timeout`**: Used to fail a test, test factory, test template, or lifecycle method if its execution exceeds a given duration
- **`@ExtendWith`**: Used to register extensions declaratively
- **`@RegisterExtension`**: Used to register extensions programmatically via fields
- **`@TempDir`**: Used to supply a temporary directory via field injection or parameter injection in a lifecycle method or test method; located in the `org.junit.jupiter.api.io` package

### Meta-Annotations and Composed Annotations

- You can define your own composed annotation that will automatically inherit the semantics of its meta-annotations
- See:
  - [`annotations/FastTest.java`](src/test/java/com/jashburn/junit5/annotations/FastTest.java)
  - [`annotations/ComposedAnnotationUsage.java`](src/test/java/com/jashburn/junit5/annotations/ComposedAnnotationUsage.java)

## Test Classes and Methods

- **Test Class**: any top-level class, static member class, or `@Nested` class that contains at least one test method; test classes must not be abstract and must have a single constructor
- **Test Method**: any instance method that is directly annotated or meta-annotated with `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, or `@TestTemplate`
- **Lifecycle Method**: any method that is directly annotated or meta-annotated with `@BeforeAll`, `@AfterAll`, `@BeforeEach`, or `@AfterEach`
- Test methods and lifecycle methods may be declared locally within the current test class, inherited from superclasses, or inherited from interfaces
  - must not be `abstract` and must not return a value
- Test classes, test methods, and lifecycle methods are not required to be `public`, but they must not be `private`
- See [`testclassesmethods/StandardTests.java`](src/test/java/com/jashburn/junit5/testclassesmethods/StandardTests.java)

## Display Names

- Test classes and test methods can declare custom display names via `@DisplayName` that will be displayed in test reports and by test runners and IDEs
  - can contain spaces, special characters, and even emojis
  - see [`displayname/DisplayNameDemo.java`](src/test/java/com/jashburn/junit5/displayname/DisplayNameDemo.java)

### Display Name Generators

- JUnit Jupiter supports custom display name generators that can be configured via `@DisplayNameGeneration`
- Values provided via `@DisplayName` always take precedence over display names generated by a `DisplayNameGenerator`
- See:
  - [`displayname/DisplayNameGeneratorReplaceUnderscores.java`](src/test/java/com/jashburn/junit5/displayname/DisplayNameGeneratorReplaceUnderscores.java)
  - [`displayname/CustomDisplayNameGenerator.java`](src/test/java/com/jashburn/junit5/displayname/CustomDisplayNameGenerator.java)
- You can use the `junit.jupiter.displayname.generator.default` configuration parameter (e.g., in `src/test/resources/junit-platform.properties`) to specify the fully qualified class name of the `DisplayNameGenerator` you would like to use by default, e.g.,

```properties
junit.jupiter.displayname.generator.default = \
    org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
```

## Assertions

- All JUnit Jupiter assertions are static methods in the [`org.junit.jupiter.api.Assertions`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html) class
- See:
  - [`assertions/AssertionsDemo.java`](src/test/java/com/jashburn/junit5/assertions/AssertionsDemo.java)
  - [`assertions/TimeoutAssertions.java`](src/test/java/com/jashburn/junit5/assertions/TimeoutAssertions.java)
- Third-party assertion libraries
  - when more power and additional functionality such as matchers are desired or required
    - e.g., for a combination of matchers and a fluent API to make assertions more descriptive and readable
  - use the built-in support for matchers provided by third-party assertion libraries such as AssertJ, Hamcrest, Truth, etc
  - e.g., as long as the Hamcrest library has been added to the classpath, you can statically import methods such as `assertThat()`, `is()`, and `equalTo()`, and then use them in tests

## Assumptions

- `Assumptions` is a collection of utility methods that support conditional test execution based on assumptions
  - all assumptions are static methods in the [`org.junit.jupiter.api.Assumptions`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assumptions.html) class
- Failed assumptions do not result in a test failure; a failed assumption results in a test being aborted
- Assumptions are typically used whenever it does not make sense to continue execution of a given test method
  - e.g., if the test depends on something that does not exist in the current runtime environment
- See [`assumptions/AssumptionsDemo.java`](src/test/java/com/jashburn/junit5/assumptions/AssumptionsDemo.java)

## Conditional Test Execution

- Entire test classes or individual test methods may be disabled via the **`@Disabled`** annotation
- Other annotation-based conditions in the [`org.junit.jupiter.api.condition`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/condition/package-summary.html) package allow developers to enable or disable containers and tests declaratively
  - operating system conditions: `@EnabledOnOs` and `@DisabledOnOs`
  - Java Runtime Environment conditions: `@EnabledOnJre` and `@DisabledOnJre`, `@EnabledForJreRange` and `@DisabledForJreRange`
  - JVM system property conditions: `@EnabledIfSystemProperty` and `@DisabledIfSystemProperty`
  - environment variable conditions: `@EnabledIfEnvironmentVariable` and `@DisabledIfEnvironmentVariable`

## Tagging

- Test classes and methods can be tagged via the **`@Tag`** annotation
- Tags can later be used to filter test discovery and execution
- Syntax rules for tags:
  - must not be null or blank
  - must not contain whitespace
  - must not contain ISO control characters
  - must not contain any of the following reserved characters:
    - comma (`,`)
    - left or right parenthesis (`(`, `)`)
    - ampersand (`&`)
    - vertical bar (`|`)
    - exclamation point (`!`)
- Example:

```java
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

@Tag("fast")
@Tag("model")
class TaggingDemo {

    @Test
    @Tag("taxes")
    void testingTaxCalculation() {
    }

}
```

## Test Execution Order

- By default, test methods are ordered using an algorithm that is deterministic but intentionally non-obvious
- Although true unit tests typically should not rely on the order in which they are executed, there are times when it is necessary to enforce a specific test method execution order
  - when writing integration tests or functional tests where the sequence of the tests is important
  - in conjunction with `@TestInstance(Lifecycle.PER_CLASS)`
- To control the order in which test methods are executed
  - annotate your test class or test interface with `@TestMethodOrder`
  - specify the desired `MethodOrderer` implementation
    - implement your own custom MethodOrderer
    - `Alphanumeric`: sorts test methods alphanumerically based on their names and formal parameter lists
    - `OrderAnnotation`: sorts test methods numerically based on values specified via the `@Order` annotation
    - `Random`: orders test methods pseudo-randomly and supports configuration of a custom seed
- See [`testexecutionorder/OrderedTestsDemo.java`](src/test/java/com/jashburn/junit5/testexecutionorder/OrderedTestsDemo.java)

## Test Instance Lifecycle

- JUnit creates a new instance of each test class before executing each test method
  - to allow individual test methods to be executed in isolation
  - to avoid unexpected side effects due to mutable test instance state
  - i.e., the default mode is `Lifecycle.PER_METHOD`
- To execute all test methods on the same test instance
  - annotate test class with `@TestInstance(Lifecycle.PER_CLASS)`
  - a new test instance will be created once per test class
  - if your test methods rely on state stored in instance variables, you may need to reset that state in `@BeforeEach` or `@AfterEach` methods
  - some benefits over the default "per-method" mode:
    - possible to declare `@BeforeAll` and `@AfterAll` on non-static methods as well as on interface default methods
    - possible to use `@BeforeAll` and `@AfterAll` methods in `@Nested` test classes
- To change the default test instance lifecycle mode for the execution of an entire test plan
  - set the `junit.jupiter.testinstance.lifecycle.default` configuration parameter to the name of an enum constant defined in `TestInstance.Lifecycle`, ignoring case
    - JVM system property
      - `-Djunit.jupiter.testinstance.lifecycle.default=per_class`
    - configuration parameter in the `LauncherDiscoveryRequest` that is passed to the `Launcher`
    - JUnit Platform configuration file
      - in `junit-platform.properties` in the root of the class path (e.g., `src/test/resources`):
      - `junit.jupiter.testinstance.lifecycle.default = per_class`

## Nested Tests

- `@Nested` tests give the test writer more capabilities to express the relationship among several groups of tests
- Only non-static nested classes (i.e. inner classes) can serve as `@Nested` test classes
- Nesting can be arbitrarily deep
- Inner classes are considered to be full members of the test class family with one exception: `@BeforeAll` and `@AfterAll` methods do not work by default
- `@BeforeEach` and `@AfterEach` methods are called for each of the current and descendant test methods
- See [`nestedtests/TestingAStackDemo.java`](src/test/java/com/jashburn/junit5/nestedtests/TestingAStackDemo.java)

## Dependency Injection for Constructors and Methods

- All prior JUnit versions - test constructors or methods were not allowed to have parameters with the standard Runner implementations
- JUnit Jupiter - both test constructors and methods are permitted to have parameters
  - allows for greater flexibility and enables Dependency Injection for constructors and methods
- [`ParameterResolver`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/extension/ParameterResolver.html)
  - defines the API for test extensions that wish to dynamically resolve parameters at runtime
  - resolve parameter at runtime for test class constructor, test method, and lifecycle method
  - 3 built-in resolvers are registered automatically
- [**`TestInfoParameterResolver`**](https://github.com/junit-team/junit5/tree/r5.6.2/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestInfoParameterResolver.java)
  - for parameter type [`TestInfo`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/TestInfo.html)
    - in `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, `@BeforeEach`, `@AfterEach`, `@BeforeAll`, and `@AfterAll` methods
  - supply an instance of `TestInfo` corresponding to the current container or test as the value for the parameter
    - provides information about the current container or test
      - display name (either a technical name - name of the test class or test method - or a custom name configured via `@DisplayName`)
      - test class
      - test method
      - associated tags
  - `TestInfo` acts as a drop-in replacement for the `TestName` rule from JUnit 4
  - see [`dependencyinjection/TestInfoDemo.java`](src/test/java/com/jashburn/junit5/dependencyinjection/TestInfoDemo.java)
- [**`RepetitionInfoParameterResolver`**](https://github.com/junit-team/junit5/tree/r5.6.2/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/RepetitionInfoParameterResolver.java)
  - for parameter type [`RepetitionInfo`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/RepetitionInfo.html)
    - in `@RepeatedTest`, `@BeforeEach`, or `@AfterEach` methods
  - supply an instance of `RepetitionInfo`
    - provides information about the current repetition and the total number of repetitions for the corresponding `@RepeatedTest`
  - note: `RepetitionInfoParameterResolver` is not registered outside the context of a `@RepeatedTest`
  - see 'Repeated Tests' for an example
- [**`TestReporterParameterResolver`**](https://github.com/junit-team/junit5/tree/r5.6.2/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TestReporterParameterResolver.java)
  - for parameter type [`TestReporter`](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/TestReporter.html)
    - in `@BeforeEach` and `@AfterEach` lifecycle methods as well as methods annotated with `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, etc.
  - supply an instance of `TestReporter`
    - used to publish additional data about the current test run
    - data can be consumed via the `reportingEntryPublished()` method in a `TestExecutionListener`
      - viewed in IDEs or included in reports
  - use `TestReporter` where you used to print information to stdout or stderr in JUnit 4
    - using `@RunWith(JUnitPlatform.class)` will output all reported entries to stdout
  - see [`dependencyinjection/TestReporterDemo.java`](src/test/java/com/jashburn/junit5/dependencyinjection/TestReporterDemo.java)
- Custom parameter resolvers
  - must be explicitly enabled by registering appropriate extensions via `@ExtendWith`
  - see
    - [`dependencyinjection/RandomParametersExtension.java`](src/test/java/com/jashburn/junit5/dependencyinjection/RandomParametersExtension.java)
    - [`dependencyinjection/RandomParametersTest.java`](src/test/java/com/jashburn/junit5/dependencyinjection/RandomParametersTest.java)
  - when the type of the parameter to inject is the only condition for your `ParameterResolver`
    - use the generic [`TypeBasedParameterResolver`](https://github.com/junit-team/junit5/tree/r5.6.2/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/support/TypeBasedParameterResolver.java) base class
    - the `supportsParameters` method is implemented behind the scenes and supports parameterized types

## Test Interfaces and Default Methods

- `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, `@TestTemplate`, `@BeforeEach`, and `@AfterEach` can be declared on interface default methods
- `@BeforeAll` and `@AfterAll` can be declared either on static methods in a test interface or on interface default methods if the test interface or test class is annotated with `@TestInstance(Lifecycle.PER_CLASS)`
- See:
  - [`testinterfaces/TestLifecycleLogger.java`](src/test/java/com/jashburn/junit5/testinterfaces/TestLifecycleLogger.java)
  - [`testinterfaces/TestInterfaceUser.java`](src/test/java/com/jashburn/junit5/testinterfaces/TestInterfaceUser.java)
- `@ExtendWith` and `@Tag` can be declared on a test interface so that classes that implement the interface automatically inherit its tags and extensions
- Another possible application of this feature is to write tests for interface contracts
  - e.g., you can write tests for how implementations of `Object.equals` or `Comparable.compareTo` should behave
    - test class can then implement both contract interfaces thereby inheriting the corresponding tests
    - see:
      - [`testinterfaces/Testable.java`](src/test/java/com/jashburn/junit5/testinterfaces/Testable.java)
      - [`testinterfaces/EqualsContract.java`](src/test/java/com/jashburn/junit5/testinterfaces/EqualsContract.java)
      - [`testinterfaces/ComparableContract.java`](src/test/java/com/jashburn/junit5/testinterfaces/ComparableContract.java)
      - [`testinterfaces/RankTest.java`](src/test/java/com/jashburn/junit5/testinterfaces/RankTest.java)

## Repeated Tests

- Repeat a test a specified number of times by annotating a method with `@RepeatedTest` and specifying the total number of repetitions
- Each invocation of a repeated test behaves like the execution of a regular `@Test` method with full support for the same lifecycle callbacks and extensions
- A custom display name can be configured for each repetition via the `name` attribute of the `@RepeatedTest` annotation
  - display name can be a pattern composed of a combination of static text and dynamic placeholders
    - `{displayName}`: display name of the `@RepeatedTest` method
    - `{currentRepetition}`: the current repetition count
    - `{totalRepetitions}`: the total number of repetitions
  - default display name for a given repetition is generated based on: `"repetition {currentRepetition} of {totalRepetitions}"`
  - predefined `RepeatedTest.LONG_DISPLAY_NAME` pattern: `"{displayName} :: repetition {currentRepetition} of {totalRepetitions}"`
- Inject an instance of `RepetitionInfo` into `@RepeatedTest`, `@BeforeEach`, or `@AfterEach` method to retrieve information about the current repetition and the total number of repetitions
- See [`repeatedtests/RepeatedTestsDemo.java`](src/test/java/com/jashburn/junit5/repeatedtests/RepeatedTestsDemo.java)

## Sources

- "JUnit 5 User Guide." <https://junit.org/junit5/docs/current/user-guide/>.
- "junit5/documentation." <https://github.com/junit-team/junit5/tree/master/documentation>.
- "JUnit 5 Tutorial: Writing Assertions With JUnit 5 Assertion API." <https://www.petrikainulainen.net/programming/testing/junit-5-tutorial-writing-assertions-with-junit-5-api/>.
- "Assertions (JUnit 5.6.2 API)." <https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html>.
- "Assumptions (JUnit 5.6.2 API). "<https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assumptions.html>.
